这是一个由学习实践逐步构建的中国象棋引擎程序。其最初的原型源于对 NegaMax 搜索算法 的学习与练习。随着研究的深入，我们不断扩展功能，引入了多种现代象棋引擎的核心技术，使其具备了较为完善的对弈能力与评估体系。

目前该引擎已实现的主要技术包括：
✦ NegaMax 搜索 (Negamax Search)
✦ Alpha-Beta 剪枝 (Alpha-Beta Pruning)
✦ 着法排序 (Move Ordering)：优先考虑置换表中的历史最佳着法与吃子着法，从而实现高效的初步排序。
✦ Zobrist 哈希 (Zobrist Hashing)：实现置换表和重复局面检测的底层方法。
✦ 置换表 (Transposition Table)
✦ 迭代深化搜索 (Iterative Deepening Search)：自深度 1 开始逐层加深，是现代引擎的标准实现。
✦ 静态搜索 (Quiescence Search)：在达到预设深度后继续扩展吃子着法，直至局面稳定，有效缓解“地平线效应”。
✦ 开局库 (Opening Book)：在开局阶段直接检索 opening_book.json 中的预设着法。
✦ 棋子机动性 (Mobility) 评估：通过计算合法移动步数衡量棋子的活跃度。
✦ 将/帅安全性 (King Safety) 评估：检测九宫格内的受攻击情况，以评估帅的安全性。
✦ 循环检测与防止 (Repetition Prevention)：利用哈希历史判定重复局面，并赋予和棋结果，避免无限循环。
✦ 棋子位置表 (Piece-Square Tables, PST)：为每种棋子定义在不同位置的价值，是实现“棋感”的关键。
✦ 渐进式评估 (Tapered Evaluation)：采用中局 (PST_MG) 与残局 (PST_EG) 两套位置表，根据场上子力计算阶段权重并动态混合评估结果。
✦ 棋子列表优化 (Piece-List Optimization)：维护玩家棋子位置列表，在评估与走法生成中避免全盘扫描，大幅提升性能。
✦ 基本时间管理 (Basic Time Management)：在搜索过程中周期性检查时间，确保在限定时间内返回最佳着法。

综合而言，该中国象棋引擎已具备现代棋类程序的核心特征与优化策略。在评估函数方面，通过 机动性评估、王安全性评估以及渐进式评估 的升级，程序在局面理解和决策质量上获得了显著提升，可视为一个功能完善且技术体系成熟的研究型项目。



TODO：优化搜索算法 (更快搜索)

您的搜索框架已经很好, 但可以通过一些技巧让它在同样的时间内搜索得更深.

1. 改进着法排序 (Move Ordering):
    * 原理: Alpha-Beta 剪枝的效率极度依赖于着法排序. 如果能优先搜索最好的着法, 就可以剪掉更多的分支.
    * 实现: 您当前的 order_moves 只是简单地区分了置换表中的最佳着法. 您可以加入 MVV-LVA (Most Valuable Victim - Least Valuable Aggressor) 
        启发式来给吃子着法排序. 简单说就是, 优先考虑用价值最低的棋子去吃价值最高的棋子 (例如, "兵吃车" 的排序就应该非常高).

2. 扩展静态搜索 (Quiescence Search):
    * 原理: 除了吃子, "将军" 也是一种会剧烈改变局面的着法.
    * 实现: 在您的 _quiescence_search 中, 除了生成和搜索所有吃子着法外, 也生成和搜索所有 "将军" 的着法.

3. 引入 "空着裁剪" (Null Move Pruning):
    * 原理: 这是一个高级剪枝技巧. 基本思想是: 如果我方放弃一步棋 (即走一步空着), 并且搜索后发现局面对手依然无法取得优势, 
        那么我方当前的局面就已经非常好了, 可以直接截断后面的搜索.
    * 实现: 在 _negamax 函数中, 当满足一定条件时 (例如, 己方不是被将军, 且剩余子力较多), 可以尝试进行一次空着搜索: score = -_negamax(board, depth - R 
        - 1, -beta, -beta + 1). 如果 score >= beta, 就认为发生了一次裁剪. (R 是一个缩减因子, 通常为2).
