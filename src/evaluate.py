# -*- coding: utf-8 -*-
"""
局面评估函数模块。

该模块负责评估一个给定的棋盘局面，为AI的搜索算法提供一个量化的分数，
以判断局面的优劣。一个好的评估函数是强大AI的关键。

评估主要基于以下两个方面：
1.  **子力价值 (Material Value)**: 不同棋子的基础价值总和。
2.  **位置价值 (Positional Value)**: 棋子在棋盘上不同位置的附加价值。
    例如，兵过河会更有价值，马在中心比在边缘更有威胁。
"""

from src.bitboard import Bitboard, PIECE_TO_BB_INDEX, BB_INDEX_TO_PIECE
from src.constants import *

# --- 棋子基础价值 ---
# 定义了每种棋子的基础分数。
PIECE_VALUES = {
    R_KING: 10000, R_GUARD: 200, R_BISHOP: 200, R_HORSE: 400, R_ROOK: 900, R_CANNON: 450, R_PAWN: 100,
    B_KING: -10000, B_GUARD: -200, B_BISHOP: -200, B_HORSE: -400, B_ROOK: -900, B_CANNON: -450, B_PAWN: -100,
}

# --- 棋子位置价值表 (Piece-Square Tables, PST) ---
# 定义了每种棋子在棋盘90个位置上不同的附加价值。
# 表格是翻转的，黑方棋子的位置价值可以直接通过 (89 - sq) 索引来获取。

# 兵的位置价值
PAWN_PST = [
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 3, 3, 3, 0, 0, 0,
    1, 2, 3, 4, 4, 4, 3, 2, 1,
    2, 3, 4, 5, 5, 5, 4, 3, 2,
    3, 4, 5, 6, 6, 6, 5, 4, 3,  # 过河兵价值增加
    10, 15, 20, 25, 25, 25, 20, 15, 10,
    10, 15, 20, 25, 25, 25, 20, 15, 10,
    10, 15, 20, 25, 25, 25, 20, 15, 10,
    10, 15, 20, 25, 25, 25, 20, 15, 10,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
]

# 炮的位置价值
CANNON_PST = [
    0, 0, 1, 1, 1, 1, 1, 0, 0,
    0, 0, 1, 2, 2, 2, 1, 0, 0,
    0, 0, 1, 2, 3, 2, 1, 0, 0,
    0, 0, 1, 2, 3, 2, 1, 0, 0,
    0, 0, 1, 1, 1, 1, 1, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 1, 2, 3, 3, 3, 2, 1, 0,
    1, 2, 3, 4, 4, 4, 3, 2, 1,
    2, 3, 4, 5, 5, 5, 4, 3, 2,
    1, 1, 1, 1, 1, 1, 1, 1, 1,
]

# 马的位置价值
HORSE_PST = [
    0, -2, 0, 0, 0, 0, 0, -2, 0,
    0, 0, 0, 2, 2, 2, 0, 0, 0,
    0, 0, 4, 4, 4, 4, 4, 0, 0,
    0, 2, 4, 6, 8, 6, 4, 2, 0,
    2, 4, 6, 8, 10, 8, 6, 4, 2,
    0, 4, 6, 8, 10, 8, 6, 4, 0,
    0, 2, 4, 6, 8, 6, 4, 2, 0,
    0, 0, 4, 4, 4, 4, 4, 0, 0,
    0, 0, 0, 2, 2, 2, 0, 0, 0,
    -2, -4, 0, 0, 0, 0, 0, -4, -2,
]

# 车的位置价值
ROOK_PST = [
    0, 0, 4, 6, 6, 6, 4, 0, 0,
    2, 2, 4, 6, 8, 6, 4, 2, 2,
    0, 0, 4, 6, 6, 6, 4, 0, 0,
    0, 0, 4, 6, 6, 6, 4, 0, 0,
    0, 0, 4, 6, 6, 6, 4, 0, 0,
    0, 0, 4, 6, 6, 6, 4, 0, 0,
    4, 4, 4, 6, 6, 6, 4, 4, 4,
    4, 4, 4, 6, 6, 6, 4, 4, 4,
    2, 2, 4, 6, 6, 6, 4, 2, 2,
    0, 0, 4, 6, 6, 6, 4, 0, 0,
]

# 士/仕的位置价值
GUARD_PST = [
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 2, 0, 2, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
]

# 象/相的位置价值
BISHOP_PST = [
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 4, 0, 4, 0, 4, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 4, 0, 0, 0, 0, 0, 4, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 4, 0, 4, 0, 4, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
]

# 将/帅的位置价值 (主要是为了将帅对脸的情况，此处简化)
KING_PST = [
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0,
]


# 将棋子类型映射到其位置价值表
PIECE_TO_PST = {
    R_PAWN: PAWN_PST, B_PAWN: PAWN_PST,
    R_CANNON: CANNON_PST, B_CANNON: CANNON_PST,
    R_ROOK: ROOK_PST, B_ROOK: ROOK_PST,
    R_HORSE: HORSE_PST, B_HORSE: HORSE_PST,
    R_BISHOP: BISHOP_PST, B_BISHOP: BISHOP_PST,
    R_GUARD: GUARD_PST, B_GUARD: GUARD_PST,
    R_KING: KING_PST, B_KING: KING_PST,
}


def evaluate(bb: Bitboard) -> float:
    """
    评估当前棋盘局面的分数。

    分数是根据子力价值和位置价值计算的。
    正分表示红方优势，负分表示黑方优势。

    Args:
        bb (Bitboard): 要评估的棋盘局面。

    Returns:
        float: 局面的评估分数。
    """
    score = 0
    # 遍历所有棋子类型
    for piece_bb_idx in range(14):
        piece_type = BB_INDEX_TO_PIECE[piece_bb_idx]
        piece_bb = bb.piece_bitboards[piece_bb_idx]

        # 遍历该类型棋子的每一个棋子
        temp_bb = piece_bb
        while temp_bb:
            # 1. 加上棋子的基础子力价值
            score += PIECE_VALUES.get(piece_type, 0)

            # 2. 加上棋子的位置价值
            sq = (temp_bb & -temp_bb).bit_length() - 1
            pst = PIECE_TO_PST.get(piece_type)
            if pst:
                # 黑方棋子需要翻转棋盘来获取位置价值
                if piece_type < 0:
                    score -= pst[89 - sq]
                else:
                    score += pst[sq]

            # 从位棋盘中移除当前处理的棋子，以便处理下一个
            temp_bb &= temp_bb - 1

    return score


if __name__ == '__main__':
    bb = Bitboard('rnbakabnr/9/1c5c1/p1p1p1p1p/9/9/P1P1P1P1P/1C5C1/9/RNBAKABNR w - - 0 1')
    print(evaluate(bb))
